# data-structure

## 概论

- 数据元素
- 数据项
- 数据对象
- 数据结构
  - 线性结构
  - 树形结构
  - 图结构
 
---

## 算法

- 程序=数据结构+算法
- 性质
  - 有穷性 - 算法必须有穷，程序可以无穷，死循环不具备有穷性
  - 确定性 - 有明确意义，无歧义，相同输入有相同输出
  - 可行性 - 算法中描述操作都可以通过已经实现的基本运算执行有限次来实现
  - 输入
  - 输出
- 优秀算法特质
  - 正确性
  - 可读性
  - 健壮性（输入非法数据时能适当作出反应或处理）
  - 高效率与低存储量需求（时间空间复杂度低）
- 算法效率的度量
  - 时间复杂度
    - 事先预估算法时间开销T(n)与问题规模n的关系
    - 时间开销表达式只保留阶数高的部分，大Ｏ表示法
      - 加法规则：多项相加，只保留最高阶的项，且系数变为1 
      - 乘法规则：多项相乘，都保留
      - Ｏ(1)<Ｏ(logn)<Ｏ(n)<Ｏ(n^2)<Ｏ(n^3)<Ｏ(2^n)<Ｏ(n!)<Ｏ(n^n)
      - 顺序执行的代码只影响常数项，可忽略
      - 若嵌套循环语句，挑选一个基本操作，分析其与n关系即可
      - 若多层嵌套循环，只需关注最深层循环的次数
      - 最差时间复杂度/平均时间复杂度（每个位置概率？）
  - 空间复杂度
    - 算法原地工作 - 算法所需内存空间为常量
    - 空间复杂度=递归调用的深度

---

## 线性表

- 线性表中所有元素数据类型都相同，有先后次序
- 线性表术语
  - 表长n（若n=0则称空表）
  - 位序i（表明元素是线性表中的第i个，从1开始，但数组下标由0开始）
  - 表头元素a1
  - 表尾元素an
  - 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继
- 线性表基本操作：创销，增删改查
  - 初始化表，分配内存空间
  - 销毁表，释放内存空间
  - 插入操作
  - 删除操作
  - 按值查找
  - 按位查找
  - 求表长
  - 输出操作
  - 判空操作
- tips:
  - 传入参数的引用&（修改结果要带回来 int test(int& x)）
  - 关键字sizeof(elem)可知元素大小
- 顺序表：用顺序存储方式来实现的线性表
  - 把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中
  - 静态分配：
    - 用静态数组存放
  - 动态分配：
    - C：malloc，free（#include <stdlib.h>）
    - C++：new，delete
- 链表：用链式存储方式来实现的线性表 

---

## 树

- 基本概念：
  - 根结点/分支结点/叶子结点/边/空树/非空树/子树(递归定义的数据建构)
  - 祖先结点/子孙结点/双亲结点(父节点)/孩子结点/兄弟结点/堂兄弟结点
  - 路径(单向，从上往下)/路径长度(指经过的边的长度)
  - 结点的层次/深度：根在第1/0层，从上往下数
  - 结点的高度：叶节点高度1，从下往上数(树的高度：一共多少层)
  - 结点的度：有几个孩子/分支(树的度：各个结点的度的最大值)
  - 有序树(从左到右有次序，不可互换)/无序树
  - 森林：互不相交的树的集合
  - 除了根结点外，任何一个节点都有且只有一个前驱
 
- 常考性质：
  - 结点数=总度数/边+1
  - 度为m的树(至少一个结点度为m，其余不超过m，一定非空)/m叉树(每个结点最多m孩，可以都达不到m，可以空树)
  - 度为m的树/m叉树的第i层最多有m^(i-1)个结点
  - 高度为h的m叉树至多有(m^h-1)/(m-1)个结点(等比求和)
  - 高度为h的m叉树至少有h个结点；高度为h、度为m的树至少有h+m-1个结点
  - 有n个结点的m叉树的最小高度为logm\[n(m-1)+1](高度最小情况，所有结点都有m个孩子)
 
- 二叉树：
  - 根结点/左子树/右子树(有序树)
  - 特殊二叉树：
    - 满二叉树：高度为h，且含有2^h-1个结点的二叉树(一种特殊的完全二叉树)
      - 只有最后一层有叶子结点
      - 不存在度为1的结点
      - 按层序从1开始编号，结点i的左孩子为2*i，右孩子为2*i+1，父结点为i/2(若有)
    - 完全二叉树：每个结点都与相应满二叉树对应
      - 只有最后两层可能有叶子结点
      - 最多只有一个度为1的结点(一定左孩子)
      - 编号同满二叉树
      - i<=n/2为分支结点，else为叶子结点
    - 二叉排序树：左子树上所有结点关键字小于根结点；右子树上所有结点关键字大于根结点
    - 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1
  - 常考性质：
    - n0=n2+1(叶子结点比二分枝结点多一个)
      - n=n0+n1+n2
      - n=n1+2*n2+1
    - 二叉树的第i层最多有2^(i-1)个结点
    - 高度为h的二叉树至多有(2^h-1)个结点(满二叉树)
    - 完全二叉树：
      - 有n个结点的完全二叉树的高度h为log2(n+1)向上取整/log2(n)+1向下取整
      - n个结点的完全二叉树，推出n0,n1,n2
        - n1=0/1
        - n0=n2+1 -> n0+n2一定奇数
       
- 二叉树的存储结构
  - 顺序存储：完全二叉树才，不然空间浪费
    - 数组存储，类型为结构体(内置bool判断是否为空，以及Type value存放数据元素)，索引编号可推断其位置(bfs)
  - 链式存储：
    - n个结点的二叉链表共有n+1个空链域(可用于构造线索二叉树)
      ```cpp
      struct ElemType{
          int value;
      };
      typedef struct BiTNode{
          ElemType data;  //数据域
          struct BiTNode *lchild,*rchild;  //左、右孩子指针
      }BiTNode,*BiTree;

      //定义一棵空树 root的类型为指向BiTNode的指针，即root为指针
      BiTree root = nullptr;

      //插入根结点
      root = new BiTNode;  //创建了一个BiTNode类型的新对象，并赋地址给root，new后跟数据类型，左值为指针
      root->data.value = 10;
      root->lchild = nullptr;
      root->rchild = nullptr;

      delete root;
      root = nullptr;     
      ```
    - 如果需要经常查找父结点，可在结构体中再定义一个指向父结点的指针，构成三叉链表，否则从根结点开始遍历寻找
- 
     
---

## 
